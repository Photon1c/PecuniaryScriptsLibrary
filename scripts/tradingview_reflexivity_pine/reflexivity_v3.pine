//@version=5
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// REFLEXIVITY INDEX 3.2 - ENHANCED (AUTO IV)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Purpose: Enhanced reflexivity index with auto-calculated gamma levels and VIX IV
// Type: Sub-pane indicator (separate chart below price)
// Key Features:
//   - Auto-calculate gamma levels from price action (VWAP + volume/range lookback)
//   - Manual level override option
//   - VIX-based IV sourcing with ATR proxy fallback
//   - Dynamic HV calculation (131-bar default)
//   - Reflexivity score (0-1 normalized scale)
//   - HR/EOM with signal confirmation bars
//   - Regime detection: DRY BAY, DRAIN TILT, CONTAINMENT
//   - Roundtable projection with dynamic zones and IV-based bias
//   - Weekend/next session bias logic
// Use Case: Automated gamma level detection with comprehensive reflexivity scoring and projection
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
indicator("Reflexivity Index 3.2 - Enhanced (Auto IV)", overlay=false, max_lines_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Auto-Calculate Settings
autoCalcLevels = input.bool(false, "Auto-Calculate Gamma Levels", group="Auto-Calc", tooltip="Use price action to estimate key levels")
volLookback   = input.int(20, "Volume/Range Lookback", group="Auto-Calc", minval=5, maxval=100)
strikeSpacing = input.float(5.0, "Strike Spacing Estimate", group="Auto-Calc", minval=1.0, step=0.5, tooltip="Typical distance between strikes")

// Manual Override (used when auto-calc is off)
// Updated to today's levels
flipLevel = input.float(665.18, "Manual: Gamma Flip Level", group="Manual Gamma", step=0.01)
callWall  = input.float(665.00, "Manual: Call Wall", group="Manual Gamma", step=0.01)
putWall   = input.float(660.00, "Manual: Put Wall", group="Manual Gamma", step=0.01)

// Volatility Settings
useDynHV  = input.bool(true, "Use Dynamic HV", group="Volatility", tooltip="Calculate HV from price data")
// Todayâ€™s HV length left as-is
hvLen     = input.int(131, "HV Length", group="Volatility", minval=10)

// New: auto IV from VIX
useVixIv  = input.bool(true, "Use VIX as IV Source", group="Volatility", tooltip="Pull daily IV proxy from CBOE:VIX")
ivInput   = input.float(19.47, "Manual: Implied Volatility %", group="Volatility", step=0.01)
hvInput   = input.float(14.66, "Manual: Historical Volatility %", group="Volatility", step=0.01)
useAtrProxy = input.bool(true, "Use ATR% as IV Proxy", group="Volatility", tooltip="Estimate IV from ATR when manual IV unavailable")

// Component Weights
alphaBias = input.float(0.30, "Î±: GPD Bias", group="Weights", minval=0, step=0.05)
betaBias  = input.float(0.50, "Î²: Tension Bias", group="Weights", minval=0, step=0.05)
wTension  = input.float(0.65, "Tension Weight", group="Weights", minval=0, maxval=1, step=0.05)
kAccel    = input.float(0.50, "Îº: IV Acceleration", group="Weights", minval=0, step=0.05)

// Smoothing
nAccel    = input.int(3, "IV Accel Period", group="Smoothing", minval=1)
nSmooth   = input.int(3, "Score Smooth Period", group="Smoothing", minval=1)
sigConfirm= input.int(1, "Signal Confirmation Bars", group="Smoothing", minval=0, maxval=3)

// Scaling
scoreSens = input.float(1.0, "Score Sensitivity", group="Scaling", minval=0.1, maxval=3.0, step=0.1, tooltip="Multiplier for score amplitude")

// Display
showHUD         = input.bool(true, "Show Info Table", group="Display")
showMarks       = input.bool(true, "Show Signals", group="Display")
showVerbose     = input.bool(false, "Show Verbose Label", group="Display")
showDiagnostics = input.bool(false, "Show Debug Plots", group="Display")
showRoundtable  = input.bool(true, "Show Roundtable Projection", group="Display")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
clamp01(x) => math.max(0.0, math.min(1.0, x))

confirmedCross(src, level, dir, conf) =>
    cross = dir > 0 ? ta.crossover(src, level) : ta.crossunder(src, level)
    if conf == 0
        cross
    else if conf == 1
        cross and (dir > 0 ? src >= level : src <= level)
    else if conf == 2
        cross and (dir > 0 ? src >= level and src[1] >= level : src <= level and src[1] <= level)
    else
        cross and (dir > 0 ? src >= level and src[1] >= level and src[2] >= level : src <= level and src[1] <= level and src[2] <= level)

roundToStrike(price, spacing) => math.round(price / spacing) * spacing

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUTO-CALCULATE GAMMA LEVELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
spot = close

calcGammaLevels() =>
    var float autoFlip = na
    var float autoCallWall = na
    var float autoPutWall = na
    
    vwap20 = ta.vwap(spot)
    highVol = ta.highest(high, volLookback)
    lowVol  = ta.lowest(low, volLookback)
    
    autoFlip     := roundToStrike(vwap20, strikeSpacing)
    autoCallWall := roundToStrike(highVol, strikeSpacing)
    autoPutWall  := roundToStrike(lowVol, strikeSpacing)
    
    if autoFlip >= autoCallWall
        autoFlip := autoCallWall - strikeSpacing
    if autoFlip <= autoPutWall
        autoFlip := autoPutWall + strikeSpacing
        
    [autoFlip, autoCallWall, autoPutWall]

[autoFlip, autoCallWall, autoPutWall] = calcGammaLevels()

flip_eff = autoCalcLevels ? autoFlip     : flipLevel
cw_eff   = autoCalcLevels ? autoCallWall : callWall
pw_eff   = autoCalcLevels ? autoPutWall  : putWall

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VOLATILITY CALCULATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ret  = math.log(spot / math.max(nz(spot[1], spot), 1e-9))
hvD  = ta.stdev(ret, hvLen) * math.sqrt(252.0)
hv   = useDynHV ? hvD : hvInput / 100.0

// IV estimation
atrPct        = ta.atr(14) / math.max(spot, 1e-9)
atrAnnualized = atrPct * math.sqrt(252.0)
vixIv         = request.security("CBOE:VIX", "D", close) / 100.0

ivManual  = ivInput / 100.0
ivProxy   = useAtrProxy ? atrAnnualized : ivManual
ivCore    = useVixIv ? vixIv : ivProxy
iv        = math.max(ivCore, 0.01)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAMMA STRUCTURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
rng = math.max(1.0, math.abs(cw_eff - pw_eff))

wallBias = clamp01((cw_eff - spot) / rng)

gpdRaw      = (spot - flip_eff) / rng
gpd         = math.abs(gpdRaw)
gpdDirection= gpdRaw >= 0 ? 1 : -1
gpdAdj      = gpd * (1.0 + alphaBias * wallBias)

tension    = clamp01(math.abs(spot - flip_eff) / rng)
tensionAdj = tension * (1.0 + betaBias * wallBias)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MOMENTUM & ACCELERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
momBase  = math.max(iv / math.max(hv, 1e-9), 0.1)
ivDelta  = ta.change(iv)
ivAccel  = ta.ema(ivDelta, nAccel)
priceRoc = ta.roc(spot, 5)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPOSITE SCORE (0-1 NORMALIZED)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
coreShape  = gpdAdj * (wTension * tensionAdj + (1.0 - wTension))
coreScaled = coreShape * scoreSens
ivKick     = ivAccel * kAccel * 50.0

rawScore    = (momBase - 1.0) * 0.3 + coreScaled + ivKick + (priceRoc / 100.0)
reflex21Raw = ta.ema(rawScore, nSmooth)
reflex21    = clamp01(reflex21Raw * 0.5 + 0.5)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIRECTIONAL MOMENTUM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
reflexVelocity = ta.change(reflex21)
reflexAccel    = ta.change(reflexVelocity)
momentum       = ta.ema(reflexVelocity, 3) * 100

direction = momentum > 0.5 ? "â†‘ BULLISH" : momentum < -0.5 ? "â†“ BEARISH" : "â†” NEUTRAL"
momentumStrength = math.abs(momentum)
momentumColor    = momentum > 0 ? color.new(color.lime, 30) : momentum < 0 ? color.new(color.red, 30) : color.new(color.gray, 50)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HR & EOM (0-1 SCALE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ivMin  = 0.08
ivMax  = 0.30
ivNorm = clamp01((iv - ivMin) / math.max(ivMax - ivMin, 1e-6))

center      = (pw_eff + cw_eff) / 2.0
distToCenter= math.abs(spot - center) / math.max(rng / 2.0, 1e-9)
proximity   = 1.0 - clamp01(distToCenter)

hr_raw = (1.0 - proximity) * ivNorm
hr     = clamp01(hr_raw)

directionalBias = clamp01((spot - pw_eff) / rng)
eom_raw         = proximity * ivNorm * directionalBias
eom             = clamp01(eom_raw)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIGNAL LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
eomLongThresh  = 0.40
eomShortThresh = 0.35
hrHighThresh   = 0.50
hrLowThresh    = 0.40

longCond  = confirmedCross(eom, eomLongThresh, 1, sigConfirm) and hr < hrLowThresh
shortCond = confirmedCross(eom, eomShortThresh, -1, sigConfirm) and hr > hrHighThresh

plotshape(showMarks and longCond, title="Long",  style=shape.triangleup,   location=location.bottom, color=color.new(color.lime, 0), size=size.small, text="â–²")
plotshape(showMarks and shortCond, title="Short", style=shape.triangledown, location=location.top,    color=color.new(color.red, 0),  size=size.small, text="â–¼")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REGIME DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
regime      = spot > cw_eff ? "DRY BAY" : spot < pw_eff ? "DRAIN TILT" : "CONTAINMENT"
regimeColor = regime == "DRY BAY" ? color.new(color.teal, 92) : regime == "DRAIN TILT" ? color.new(color.red, 92) : color.new(color.yellow, 92)

garageState = flip_eff < pw_eff ? "Flip < Put" : flip_eff > cw_eff ? "Flip > Call" : "Inside"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLOTS (ALL 0-1 SCALE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
col = reflex21 >= 0.75 ? color.red : reflex21 >= 0.60 ? color.orange : reflex21 >= 0.40 ? color.yellow : color.teal

plot(reflex21, "Reflexivity Score", color=col, linewidth=3, style=plot.style_line)
plot(momentum / 100, "Momentum", momentumColor, 2, plot.style_histogram)

hline(0.75, "Risk",    color.new(color.red, 40),   hline.style_solid,  2)
hline(0.60, "Active",  color.new(color.orange, 50),hline.style_dashed)
hline(0.40, "Neutral", color.new(color.gray, 70),  hline.style_dotted)
hline(0.25, "Calm",    color.new(color.teal, 50),  hline.style_dashed)
hline(0.00, "Zero",    color.new(color.white, 80), hline.style_dotted)

plot(hr,  "HR (Resistance)", color.new(color.red,   40), linewidth=2)
plot(eom, "EOM (Motion)",    color.new(color.green, 40), linewidth=2)

bgcolor(regimeColor)

// Optional diagnostics

plot(hr_raw,      "HR raw",       color.new(color.red,   60), style=plot.style_circles)
plot(eom_raw,     "EOM raw",      color.new(color.green, 60), style=plot.style_circles)
plot(momBase - 1, "IV/HV - 1",    color.new(color.blue,  70))
plot(gpdAdj,      "GPD",          color.new(color.purple,80))
plot(tensionAdj,  "Tension",      color.new(color.orange,80))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INFO TABLE - FIXED POSITIONING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var table hud = table.new(position.middle_right, 2, 12, bgcolor=color.new(color.black, 15), frame_color=color.new(color.gray, 50), frame_width=2, border_width=1, border_color=color.new(color.gray, 70))

if barstate.islast and showHUD
    table.cell(hud, 0, 0, "REFLEXIVITY 3.2", text_color=color.white, bgcolor=color.new(color.blue, 20), text_size=size.normal)
    table.cell(hud, 1, 0, direction, text_color=momentum > 0 ? color.lime : momentum < 0 ? color.red : color.gray, bgcolor=color.new(color.blue, 20), text_size=size.small)
    
    table.cell(hud, 0, 1, "Mode", text_color=color.gray, text_size=size.small)
    modeText = autoCalcLevels ? "AUTO" : "MANUAL"
    table.cell(hud, 1, 1, modeText, text_color=autoCalcLevels ? color.aqua : color.orange, text_size=size.small)
    
    table.cell(hud, 0, 2, "Garage", text_color=color.gray, text_size=size.small)
    txtCC = garageState == "Inside" ? "âœ“ OK" : garageState == "Flip > Call" ? "â†‘ Beam" : "â†“ Floor"
    colCC = garageState == "Inside" ? color.green : color.orange
    table.cell(hud, 1, 2, txtCC, text_color=colCC, text_size=size.small)
    
    table.cell(hud, 0, 3, "Call Wall", text_color=color.gray, text_size=size.small)
    table.cell(hud, 1, 3, str.tostring(cw_eff, "#.##"), text_color=color.lime, text_size=size.small)
    
    table.cell(hud, 0, 4, "Flip", text_color=color.gray, text_size=size.small)
    table.cell(hud, 1, 4, str.tostring(flip_eff, "#.##"), text_color=color.yellow, text_size=size.small)
    
    table.cell(hud, 0, 5, "Put Wall", text_color=color.gray, text_size=size.small)
    table.cell(hud, 1, 5, str.tostring(pw_eff, "#.##"), text_color=color.red, text_size=size.small)
    
    table.cell(hud, 0, 6, "IV / HV", text_color=color.gray, text_size=size.small)
    ivhvText = str.tostring(iv * 100, "#.##") + "% / " + str.tostring(hv * 100, "#.##") + "%"
    table.cell(hud, 1, 6, ivhvText, text_color=color.white, text_size=size.small)
    
    table.cell(hud, 0, 7, "Score", text_color=color.gray, text_size=size.small)
    table.cell(hud, 1, 7, str.tostring(reflex21, "#.###"), text_color=col, text_size=size.normal)
    
    table.cell(hud, 0, 8, "Momentum", text_color=color.gray, text_size=size.small)
    momText = str.tostring(momentum, "#.##")
    momCol  = momentum > 0 ? color.lime : momentum < 0 ? color.red : color.gray
    table.cell(hud, 1, 8, momText, text_color=momCol, text_size=size.small)
    
    table.cell(hud, 0, 9, "HR / EOM", text_color=color.gray, text_size=size.small)
    table.cell(hud, 1, 9, str.tostring(hr, "#.##") + " / " + str.tostring(eom, "#.##"), text_color=color.white, text_size=size.small)
    
    gammaMode = spot >= flip_eff ? "Pos Î³" : "Neg Î³"
    table.cell(hud, 0, 10, "Î³ Mode", text_color=color.gray, text_size=size.small)
    table.cell(hud, 1, 10, gammaMode, text_color=spot >= flip_eff ? color.lime : color.orange, text_size=size.small)
    
    table.cell(hud, 0, 11, "Regime", text_color=color.gray, text_size=size.small)
    regTextColor = regime == "CONTAINMENT" ? color.yellow : regime == "DRAIN TILT" ? color.red : color.teal
    table.cell(hud, 1, 11, regime, text_color=regTextColor, text_size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERBOSE LABEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var label hudLabel = na
if barstate.islast and showVerbose
    label.delete(hudLabel)
    txt = "Reflexivity 3.2 | Direction: " + direction
    txt := txt + "\nScore: " + str.tostring(reflex21, "#.###")
    txt := txt + " | Momentum: " + str.tostring(momentum, "#.##")
    txt := txt + "\nIV/HV: " + str.tostring(momBase, "#.##")
    txt := txt + " | GPD: " + str.tostring(gpdAdj, "#.##")
    txt := txt + "\nHR: " + str.tostring(hr, "#.##")
    txt := txt + " | EOM: " + str.tostring(eom, "#.##")
    txt := txt + "\nWalls: " + str.tostring(pw_eff, "#.##") + " | " + str.tostring(flip_eff, "#.##") + " | " + str.tostring(cw_eff, "#.##")
    hudLabel := label.new(bar_index, reflex21, txt, style=label.style_label_left, textcolor=color.white, color=color.new(col, 70), yloc=yloc.price, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROUNDTABLE PROJECTION (AUTO ZONES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var label roundtableLabel = na

if barstate.islast and showRoundtable
    label.delete(roundtableLabel)

    ivPct = iv * 100.0

    // Dynamic zones around current walls
    float halfStep = strikeSpacing * 0.5

    upLow  = cw_eff
    upHigh = cw_eff + halfStep
    dnLow  = pw_eff - halfStep
    dnHigh = pw_eff


    bias   = "Bull Drift toward " + str.tostring(upLow, "#.##") + "â€“" + str.tostring(upHigh, "#.##")
    upZone = str.tostring(upLow, "#.##") + "â€“" + str.tostring(upHigh, "#.##")
    dnZone = str.tostring(dnLow, "#.##") + "â€“" + str.tostring(dnHigh, "#.##")
    ivNote = "Base case: IV fade â†’ drift toward upper lane."
    rtColor = color.new(color.green, 70)

    highIvThresh = 19.5
    lowIvThresh  = 15.0

    if ivPct > highIvThresh
        bias    := "Risk of slide toward lower lane"
        upZone  := str.tostring(center, "#.##") + "â€“" + str.tostring(upHigh, "#.##")
        dnZone  := str.tostring(dnLow, "#.##") + "â€“" + str.tostring(dnHigh, "#.##")
        ivNote  := "IV elevated â†’ first move more likely down toward lower lane."
        rtColor := color.new(color.red, 70)
    else if ivPct < lowIvThresh
        bias    := "Compressed drift inside mid-lane"
        upZone  := str.tostring(center, "#.##") + "â€“" + str.tostring(upHigh, "#.##")
        dnZone  := str.tostring(dnLow, "#.##") + "â€“" + str.tostring(center, "#.##")
        ivNote  := "Low IV â†’ slow grind, heavy theta bleed."


    sessLabel   = dayofweek == dayofweek.friday ? "Next Session (Mon) Bias: " : "Tomorrow Bias: "
    weekendNote = dayofweek == dayofweek.friday ?
         "OPEX parking near flip â†’ Monday gap + IV reset decides next lane." :
         "Next open IV rotation decides upper vs lower lane."

    txt = "ðŸ“Š ROUNDTABLE PROJECTION\n" +
          sessLabel + bias + "\n" +
          "Upside Zone: " + upZone + "\n" +
          "Downside Zone: " + dnZone + "\n" +
          "IV: " + str.tostring(ivPct, "#.0") + "%\n\n" +
          "ðŸ» Bear: Book neutral unless IV spikes.\n" +
          "ðŸŸ Fish: Flows idle, price gravitates toward lanes.\n" +
          "ðŸµ Monkey: Parking near flip; next sessionâ€™s IV is the trigger.\n\n" +
          ivNote + "\n" +
          weekendNote

    roundtableLabel := label.new(bar_index, 1.5, txt, style=label.style_label_left, textcolor=color.white, color=rtColor, size=size.small)
